<?php

namespace App\Crypto;

use App\Http\Controllers\Crypto\kucoin;
use App\Models\CoinBackTest;
use App\Models\coins;
use App\Models\Currency;
use App\Models\metadata;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Storage;
use Symfony\Component\Console\Output\Output;
use Illuminate\Support\Facades\Log;

class CryptoRobots
{
    private function get_active_robots()
    {
        //this function return users where has active robots
        return  metadata::where('tt', 'signalRobot')->get();
    }
    private function activate_users_robot($ActiveRobots)
    {
        $Result = [];
        foreach ($ActiveRobots as $ActiveRobotItem) {
            $MetaValue = json_decode($ActiveRobotItem->meta_value);
            $MetaValue->UserName = $ActiveRobotItem->fgstr;
            $MetaValue->status = $ActiveRobotItem->status;
            $UserName = $ActiveRobotItem->fgstr;
            $Result[$UserName] = $MetaValue;
        }
        return $Result;
    }
    private function robot_buy_by_market_price($UserRobotAttr)
    {
    }
    private function add_coin_to_user_walet_if_not_exist(string $UserName, string $CoinName)
    {
        $UserCoin = coins::where('UserName', $UserName)->where('CoinName', $CoinName)->first();
        if ($UserCoin == null) { // The user has not coin before
            $CoinData = [
                'UserName' => $UserName,
                'CoinName' => $CoinName,
                'QTY' => 0,
                'TMN' => 1,
                'ExtraInfo' => ''
            ];
            $Result = coins::create($CoinData);
            $Output = [
                'result' => true,
                'data' => $Result->id
            ];
            return $Output;
        } else { // the user has coin already
            $Output = [
                'result' => true,
                'data' => $UserCoin->id
            ];
            return $Output;
        }
    }
    private function robot_buy_by_limit_price($UserRobotAttr, $BuySignal)
    {
        $CoinName = str_replace('-USDT', '', $BuySignal);
        $UserName = $UserRobotAttr->UserName;
        $UserCoin =  $this->add_coin_to_user_walet_if_not_exist($UserName, $CoinName);
        if ($UserCoin['result']) {
            $UpdateData = [
                'Status' => 100,
                'Robot' => 0
            ];
            $UpdateData = coins::where('id', $UserCoin['data'])->update($UpdateData);
        }
        return [
            'result' => true,
            'msg' => 'initiate robot for user'
        ];
    }
    private function active_single_user_robot($UserRobotAttr, $BuySignal)
    {

        $market = $UserRobotAttr->market;
        if ($market == 2) {
            return $this->robot_buy_by_limit_price($UserRobotAttr, $BuySignal);
        } else {
            return $this->robot_buy_by_market_price($UserRobotAttr, $BuySignal);
        }
    }



    public function run_users_robots(array $Signal_Arr) // use this function on buy signal generated by analyzers
    {
        if ($Signal_Arr != []) {
            $ActiveRobots = $this->get_active_robots();
            if (count($ActiveRobots)  != 0) { // one or some users has activated robots
                $ActiveUsersRobot = $this->activate_users_robot($ActiveRobots);
                foreach ($Signal_Arr as $SignalItem) {
                    foreach ($ActiveUsersRobot as $ActiveUsersRobotItem) {
                        $this->active_single_user_robot($ActiveUsersRobotItem, $SignalItem);
                        Log::channel('slack')->info($SignalItem . ' Run Robot');
                    }
                }
                return true;
            }
        } else {
            return false;
        }
    }
    private function find_user_coins_with_request_robot()
    {
    }
    private function is_any_coin_join_to_new_robot()
    {
        $newRobotSrc = coins::where('Status', 100)->where('Robot', 0)->first(); // find if define new robot in coins
        if ($newRobotSrc == null) {
            return [
                'result' => false,
                'msg' => 'no new robot define in all users'
            ];
        }
        return [
            'result' => true,
            'data' => [
                'CoinName' => $newRobotSrc->CoinName
            ]
        ];
    }
    private function run_users_robot_with_symbol($target_symbol)
    {
        $BackTestSrc = CoinBackTest::where('curency', $target_symbol)->where('owner', 'system')->orderBy('candate', 'DESC')->first();
        $CoinPrice = $BackTestSrc->OpenPrice;
        $newRobotSrc = coins::where('Status', 100)->where('Robot', 0)->where('CoinName', $target_symbol)->get(); //find symbols where add robot before
        $CoinSrc = Currency::where('MainName', $target_symbol)->first();
        $CryptoFormola = new CryptoFormola_1;

        foreach ($newRobotSrc as $user_coin_target) {
            try {

                $cancel_after = 240;
                $TargetUser = $user_coin_target->UserName;
                $metadata_src = metadata::where('fgstr', $TargetUser)->where('tt', 'signalRobot')->where('status', 0)->first();
                if ($metadata_src != null) {
                    $Robot_roles = json_decode($metadata_src->meta_value);
                    $active_robot = $Robot_roles->active_robot;
                    $InputBaget =  $Robot_roles->InputBaget;
                    $concurnet =  $Robot_roles->concurnet;
                    $benefit =  $Robot_roles->benefit;
                    $market =  $Robot_roles->market;
                    $stop =  $Robot_roles->stop;
                    $start =  $Robot_roles->start;
                    $timelimit =  $Robot_roles->timelimit;
                    $behav =  $Robot_roles->behav;
                    if ($active_robot <= $concurnet) { // user defined add new robot
                        $MyKucoin = new kucoin($TargetUser);
                        $Price = $CoinPrice + ($CoinPrice * $start / 100);
                        $Price = number_format($Price, 10);
                        $Price = $CryptoFormola->numbervalidation($CoinSrc['priceIncrement'], $Price);
                        $Size = $InputBaget / $Price;
                        $Size = $CryptoFormola->numbervalidation($CoinSrc['baseMinSize'], $Size);
                        $data = [
                            'side' => 'buy',
                            'symbol' => $target_symbol . '-USDT',
                            'type' => 'limit',
                            'price' => $Price,
                            'size' => $Size,
                            'cancelAfter' => $cancel_after
                        ];
                        $result = $MyKucoin->make_order($data);
                        if (isset($result['orderId'])) {
                            $RobotInfo = $user_coin_target->robot_info;
                            if ($RobotInfo == null) {
                                $robot_info = [];
                            } else {
                                $robot_info = json_decode($RobotInfo, true);
                            }
                            $RobotData = [
                                'TimeStamp' => date("Y-m-d H:i:s"),
                                'Status' => 'init',
                                'orderId' => $result['orderId']
                            ];
                            array_push($robot_info, $RobotData);
                            $update_data = [
                                'robot_info' => $robot_info,
                                'Robot' => 1  // waiting for buy
                            ];
                            coins::where('id', $user_coin_target->id)->update($update_data);
                            unset($MyKucoin);
                        }
                    }
                }
            } catch (\Exception $e) {

                continue;
            }
        }
    }
    private function remove_order_from_user_coins($CoinId)
    {
        $updateData = [
            'Status' => 0,
            'Robot' => null,
            'robot_info' => null
        ];
        coins::where('id', $CoinId)->update($updateData);
        return true;
    }
    private function success_buy_robot($CoinId, $UserName = null)
    {
        if ($UserName == null) {
            $Coinsrc = coins::where('id', $CoinId)->first();
            $UserName = $Coinsrc->UserName;
        }
        $updateData = [
            'Robot' => 2,
        ];
        coins::where('id', $CoinId)->update($updateData);
        $CryptoFunctions = new CryptoFunctions;
        $CryptoFunctions->UserRenewWalet($UserName);
        return true;
    }
    private function make_stop_less($deal_attr, $UserName)
    {
        $KuCoin = new kucoin($UserName);
        $dealFunds = $deal_attr['dealFunds'];
        $size = $deal_attr['size'];
        $OpenOrdersItem = $deal_attr['OpenOrdersItem'];
        $stop = $deal_attr['stop'];
        $UnitPrice = $dealFunds / $size;
        $stopPrice =  $UnitPrice - ($UnitPrice * $stop / 100);
        $CoinData = json_decode($OpenOrdersItem->ExtraInfo, 1);
        $stopPrice = number_format($stopPrice, 10);
        $CryptoFormola = new CryptoFormola_1;
        $stopPrice = $CryptoFormola->numbervalidation($CoinData['priceIncrement'], $stopPrice);
        $size += $OpenOrdersItem->QTY;
        $result =  $KuCoin->make_stop_Order('sell', $OpenOrdersItem->CoinName . '-USDT', $stopPrice, $size);
        //TODO:handle check buy
        coins::where('UserName', $UserName)->where('CoinName', $OpenOrdersItem->CoinName)->update(['Robot' => 2]);
    }
    private function check_buy_request()
    {
        $OpenOrders = coins::where('Status', 100)->where('Robot', 1)->get();
        $eee = count($OpenOrders);
        if (count($OpenOrders) == 0) {
            return true;
        }
        foreach ($OpenOrders as $OpenOrdersItem) {
            $RobotInfo = json_decode($OpenOrdersItem->robot_info, true);
            foreach ($RobotInfo as $RobotInfoItem) {
                if ($RobotInfoItem['Status'] == 'init') {
                    $CryptoFunctions = new CryptoFunctions;
                    $CryptoFunctions->UserRenewWalet($OpenOrdersItem->UserName);
                    $OpenOrdersItem_new =  coins::where('id', $OpenOrdersItem->id)->first();
                    $orderId = $RobotInfoItem['orderId'];
                    $MyKucoin = new kucoin($OpenOrdersItem->UserName);
                    $OrderSrc = $MyKucoin->get_order($orderId);
                    unset($MyKucoin);
                    $isActive = $OrderSrc['isActive'];
                    if ($isActive) { // if order is active 
                        // noting to do wait more to terminate order
                    } else {
                        $cancelExist = $OrderSrc['cancelExist'];
                        if ($cancelExist) { // if order canceled
                            $this->remove_order_from_user_coins($OpenOrdersItem->id);
                        } else {
                            if ($OrderSrc['dealSize'] > 0) { // make order success
                                $MetaData = metadata::where('tt', 'signalRobot')->where('fgstr', $OpenOrdersItem->UserName)->first();
                                $meta_value = json_decode($MetaData->meta_value, true); //TODO: increase active_robot
                                $stop = $meta_value['stop'];
                                $benefit = $meta_value['benefit'];
                                $deal_attr = [
                                    'dealFunds' => $OrderSrc['dealFunds'],
                                    'size' => $OrderSrc['size'],
                                    'OpenOrdersItem' => $OpenOrdersItem_new,
                                    'stop' => $stop,
                                ];
                                $this->make_stop_less($deal_attr, $OpenOrdersItem->UserName);
                            }
                        }
                    }
                }
            }
            dd($RobotInfo);
        }
    }
    private function buy_signal()
    {
        $Crawler = true;
        while ($Crawler) {
            $newRobots = $this->is_any_coin_join_to_new_robot();
            $Crawler = $newRobots['result'];
            if ($Crawler) {
                $newRobots = $newRobots['data'];
                $TargetCoin = $newRobots['CoinName'];
                $this->run_users_robot_with_symbol($TargetCoin); //TODO: fix robot 
            }
        }
    }
    private function robot_loop($LoopNumber)
    {
        $this->buy_signal();
        $this->check_buy_request();
        return true;
    }
    private function traders_robots()
    {
        if (Storage::exists('LoopCounter.txt')) {
            $LoopCounter = Storage::get('LoopCounter.txt');
            $LoopNumber = ($LoopCounter % 5) + 1;
            $LoopCounter++;
            if ($LoopCounter > 1440) { //reset loop counter after 24 hours
                $LoopCounter = 1;
            }
            Storage::put('LoopCounter.txt', $LoopCounter);
        } else {
            $LoopCounter = 1;
            Storage::put('LoopCounter.txt', $LoopCounter);
        }
        return $this->robot_loop($LoopNumber);
    }

    public function trader_robot_start($req_type)
    {
        if ($req_type == 'robot') {
            return  $this->traders_robots();
        }
    }
}
